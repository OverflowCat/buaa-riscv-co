lw x5, 0(x0)            # 将内存地址 0(x0) == 0 处的值(h00000001)加载到寄存器 x5
add x6, x5, x5          # x6 = 2 * x5 == 2
or x10, x5, x6          # x10 = x5 | x6 == 0b0001 | 0b0010 == 0b0011 = 3
add x10, x10, x5        # x10 = x10 + x5 == 3 + 1 = 4
add x12, x6, x6         # x12 = x6 + x6 == 4
and x11, x5, x6         # x11 = x5 & x6 == 0
sw x10, 4(x10)          # 将 x10 的值存储到内存地址 4(x10) == 4 + 4 == 8 处，mem[8] == 4
add x11, x11, x6        # x11 = x11 + x6 == 0 + 2 = 2
sub x6, x6, x0          # x6 = x6 - x0 == 2 - 0 = 2
lw x13, 12(x12)         # x13 = mem[4 + 12] == mem[16] == 0
sub x13, x13, x6        # x13 -= x6 == -2
beq x13, x11, -44       # 如果x13等于x11，跳转到当前指令前的44个指令偏移(-2 != 2)
add x11, x11, x6        # x11 += x6 == 2 + 2 == 4
sub x13, x13, x6        # x13 -= x6 == -2 - 2 == -4
beq x13, x11, 8         # 如果x13等于x11，跳转到当前指令后的8个指令偏移
sw x6, 4(x6)            # 将x6的值存储到内存地址4(x6)处
and x11, x11, x0        # x11 = x11 & x0，将x11与x0按位与并存储结果
add x6, x6, x5          # x6 = x6 + x5，将x6和x5相加的结果存储在x6中
sw x6, 4(x12)           # 将x6的值存储到内存地址4(x12)处
beq x0, x0, 0           # 总是跳转到下一条指令，相当于无操作（NOP）
bne x0, x3, 32          # 如果x0不等于x3，跳转到当前指令后的32个指令偏移
addi x26, x0, 1         # x26 = x0 + 1，将1存储到x26中
addi x27, x0, 0         # x27 = x0 + 0，将0存储到x27中
lui x2, 65536           # 将立即数65536加载到x2的高位
sw x27, 0(x2)           # 将x27的值存储到内存地址0(x2)处
lui x2, -2              # 将-2加载到x2的高位
sw x27, 0(x2)           # 将x27的值存储到内存地址0(x2)处
beq x0, x0, 0           # 总是跳转到下一条指令，相当于无操作（NOP）
addi x26, x0, 1         # x26 = x0 + 1，将1存储到x26中
addi x27, x0, 1         # x27 = x0 + 1，将1存储到x27中
lui x2, 65536           # 将立即数65536加载到x2的高位
sw x27, 0(x2)           # 将x27的值存储到内存地址0(x2)处
lui x2, -2              # 将-2加载到x2的高位
sw x27, 0(x2)           # 将x27的值存储到内存地址0(x2)处
beq x0, x0, 0           # 总是跳转到下一条指令，相当于无操作（NOP）
add x26, x0, x0         # x26 = x0，将x0的值赋给x26
add x27, x0, x0         # x27 = x0，将x0的值赋给x27
